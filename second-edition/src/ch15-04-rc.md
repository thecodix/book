## `Rc<T>`, el Puntero Inteligente de Referencia Contada

En la mayoría de los casos, la posesión es clara: usted sabe exactamente cuál variable
tiene un valor dado. Sin embargo, hay casos en los que un solo valor pudiera tener
múltiples dueños. Por ejemplo, en estructuras gráficos de información, múltiples bordes podrían
apuntar al mismo nodo, y ese nodo es conceptualmente poseído por todos los bordes que 
apuntan hacia él. Un nodo no debería ser limpiado a menos de que no tenga ningún borde 
apuntando hacia él.

Para habilitar posesiones múltiples, Rust tiene un tipo llamado `Rc<T>`. 
Su nombre es un abreviación de *reference counting*, que mantiene un seguimiento 
del número de referencias a un valor para saber si un valor continua en uso o no. 
Sí hay hay cero referencias para un valor, el valor se puede limpiar sin que ninguna
referencia se vuelva inválida.

Imagine a `Rc<T>` como un televisor en una sala familiar. Cuando una persona 
entra en la sala para ver la televisión, ellos lo encienden. Otros pueden entrar a l
a habitación y mirar la televisión. Cuando la última persona sale de la 
habitación, apagan  el televisor porque ya no se está usando. Si alguien apaga el televisor
mientras otros todavía lo miran, habría reclamo de los televidentes restantes!

Usamos el tipo `Rc<T>` cuando queremos distribuir algunos datos en el cúmulo para
varias partes de nuestro programa para leer, y no podemos determinar en el tiempo de compilación
qué parte terminará usando los datos de uúltimo. Si supiéramos qué parte terminaría
de último, nosotros podríamos hacer que esa parte sea el propietario de los datos y las reglas de posesion normal
forzadas en la compilación tendrían efecto.

Note que `Rc<T>` solo es usado en escenarios de subproceso único. Cuando discutamos
concurrencia en el Capítulo 16, vamos a cubrir cómo hacer cuenteo de referencias en
programas multiproceso

### Usando `Rc<T>` para Compartir Información

Vamos a regresar a nuestro ejemplo de lista de debilidades en el Listado 15-5. 
Recuerda que lo definimos usando `Box<T>`. En esta ocasión, vamos a crear dos listas que compartan 
la propiedad de una tercera lista, que conceptualmente va a lucir similar a la Figura 15-3:

<img alt="Dos listas que comparten la posesión de una tercera lista" src="img/trpl15-03.svg" class="center" />

<span class="caption">Figura 15-3: 2 listas, `b` y `c`, compartiendo la posesión de una tercera lista, `a`</span>

Nosotros vamos a crear la lista `a` que contiene 5 y luego 10. Des÷ués haremos dos 
listas más: `b` que comienza con 3 y `c` que comienza con 4. Ambas `b` y` c`
listas continuarán en la primera lista `a` que contiene 5 y 10. Es decir, 
ambas listas compartirán la primera lista que contiene 5 y 10.


Intentando implementar este escenario usando nuestra definición de `List` con` Box<T> `
no va a funcionar, como se muestra en el Listado 15-17:

<span class="filename">Filename: src/main.rs</span>

```rust,ignore
enum List {
    Cons(i32, Box<List>),
    Nil,
}

use List::{Cons, Nil};

fn main() {
    let a = Cons(5,
        Box::new(Cons(10,
            Box::new(Nil))));
    let b = Cons(3, Box::new(a));
    let c = Cons(4, Box::new(a));
}
```

<span class="caption">Listing 15-17: Demonstrating we’re not allowed to have
two lists using `Box<T>` that try to share ownership of a third list</span>

When we compile this code, we get this error:

```text
error[E0382]: use of moved value: `a`
  --> src/main.rs:13:30
   |
12 |     let b = Cons(3, Box::new(a));
   |                              - value moved here
13 |     let c = Cons(4, Box::new(a));
   |                              ^ value used here after move
   |
   = note: move occurs because `a` has type `List`, which does not implement
   the `Copy` trait
```

Las variantes `Cons` poseen la información que ellos guardan, de manera que cuando creamos 
la lista `b`, `a` se mueve dentro de `b` y` b` posee `a`. Después, cuando tratamos de 
usar `a` nuevamente al crear a `c`, no lo tenemos permitido porque `a` ha sido movida.

Podríamos cambiar la definición de `Contras` para en su lugar mantener referencias, pero después
tendríamos que especificar los parámetros de por vida. Al especificar los parámetros de por vida, 
estaríamos especificando que cada elemento en la lista vivirá 
por lo menos tanto tiempo como toda la lista. El verificador de préstamos no 
nos permitiría compilar `let a = Cons (10, & Nil);` por ejemplo, porque el valor 
temporal `Nil` sería descartado antes de que `a` puudiera tomar una referencia de él.

En cambio, vamos a cambiar nuestra definición de `List` para usar `Rc<T>` en lugar de
`Box<T>`, como se muestra en el Listado 15-18. Cada variante `Cons` ahora mantendrà un valor
y un `Rc<T>` apuntando a una `Lista`. Cuando creamos `b`, en lugar de tomar
propiedad de `a`, vamos a clonar `Rc<List>` que `a` está manteniendo, lo cual
incrementa el número de referencias de uno a dos y permite compartir a `a` y a `b` la 
propiedad de la información en ese `Rc<List>`. También vamos a clonar a `a` cuando creemos
`c`, lo cual aumenta el número de referencias de dos a tres. Cada vez que
llamemos a `Rc::clone`, la cuenta de referencia a la información dentro de `Rc<List>` va a
aumentar, y la información no se borrará a menos que haya cero referencias hacia ella:


<span class="filename">Filename: src/main.rs</span>

```rust
enum List {
    Cons(i32, Rc<List>),
    Nil,
}

use List::{Cons, Nil};
use std::rc::Rc;

fn main() {
    let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));
    let b = Cons(3, Rc::clone(&a));
    let c = Cons(4, Rc::clone(&a));
}
```

<span class="caption">Listing 15-18: A definition of `List` that uses
`Rc<T>`</span>
    
Necesitamos agregar un enunciado `use` para traer a `Rc <T> ` dentro del alcance porque no está
en el preludio. En `main`, creamos la lista que contiene 5 y 10 y la guardamos en
un nuevo `Rc<List>` en `a`. Luego, cuando creamos `b` y `c`, llamamos a la función
`Rc::clone` y pasamos una referencia a `Rc<List>` en `a` como un
argumento.    

Podríamos haber llamado a `a.clone()` en lugar de a `Rc::clone(&a)`, pero la convención de Rust
es usar `Rc::clone` en este caso. La implementación de `Rc::clone` no hace una copia profunda de 
todos los datos como sí hacen la mayoría de los tipos de 
implementaciones de `clone`. La llamada a `Rc::clone` solo incrementa el
conteo de referencia, el cual no toma mucho tiempo. Las copias profundas de datos pueden tomar
mucho tiempo. Al usar `Rc::clone` para el cuenteo de referencias, podemos diferenciar visualmente 
entre las clases de copia profunda de los clones y los tipos de clones que
aumentan el cuenteo de referencia. Al buscar problemas de rendimiento en el
código, solo debemos considerar los clones de copia profunda e ignorar las llamadas a
`Rc::clone`.

### Clonar un `Rc<T>` Incrementa el Cuenteo de Referencias

Cambiemos nuestro ejemplo con el que veníamos trabando en el listado 15-18 para que 
podamos ver el cambio en el cuento de referencia mientras creamos y soltamos referencias en la `Rc<List>` en `a`.

En el Listado 15-19, vamos a cambiar `main` por lo que tiene un alcance interno alrededor de la lista `c`;
luego podemos ver cómo cambia el cuenteo de referencias cuando `c` se pone fuera de alcance. En
cada punto del programa donde cambia el cuenteo de referencias, vamos a imprimir el
cuenteo de referencia, que podemos recibir llamando a la función `Rc::strong_count`.
Esta función tiene como nombre `strong_count` y no `count` porque el tipo `Rc<T>` 
también tiene un `weak_count`; vamos a ver para qué se usa `weak_count` en la sección de
"Prevención de Ciclos de Referencia".

<span class="filename">Filename: src/main.rs</span>

```rust
# enum List {
#     Cons(i32, Rc<List>),
#     Nil,
# }
#
# use List::{Cons, Nil};
# use std::rc::Rc;
#
fn main() {
    let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));
    println!("count after creating a = {}", Rc::strong_count(&a));
    let b = Cons(3, Rc::clone(&a));
    println!("count after creating b = {}", Rc::strong_count(&a));
    {
        let c = Cons(4, Rc::clone(&a));
        println!("count after creating c = {}", Rc::strong_count(&a));
    }
    println!("count after c goes out of scope = {}", Rc::strong_count(&a));
}
```

<span class="caption">Listing 15-19: Printing the reference count</span>

This code prints the following:

```text
count after creating a = 1
count after creating b = 2
count after creating c = 3
count after c goes out of scope = 2
```

Podemos ver que `Rc<List>` en `a` tiene un conteo inicial de referencia de uno;
y entonces cada vez que llamamos a `clone`, el conteo sube en uno. Cuando `c` se pone fuera de
alcance, el conteo se baja en uno. No tenemos que llamar a una función para disminuir
el conteo de referencias como sí sucede al tener que llamar a `Rc::clone` para aumentar el conteo de referencia
: la implementación de la característica `Drop` disminuye el conteo de referencias
automáticamente cuando un valor `Rc<T>` se pone fuera de alcance.

Lo que no podemos ver en este ejemplo es que cuando `b` y luego `a` se ponen fuera de alcance
al final de `main`, el conteo es entonces 0, y `Rc<List> `se borra
completamente en ese punto. Usar `Rc<T>` permite que un valor único tenga
múltiples dueños, y el conteo asegura que el valor sigue siendo válido siempre y cuando 
alguno de los dueños todavía exista.

Via immutable references, `Rc<T>` allows us to share data between multiple
parts of our program for reading only. If `Rc<T>` allowed us to have multiple
mutable references too, we might violate one of the borrowing rules discussed
in Chapter 4: multiple mutable borrows to the same place can cause data races
and inconsistencies. But being able to mutate data is very useful! In the next
section, we’ll discuss the interior mutability pattern and the `RefCell<T>`
type that we can use in conjunction with an `Rc<T>` to work with this
immutability restriction.
